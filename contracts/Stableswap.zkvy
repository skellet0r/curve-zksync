# @zk-version 1.2.0
"""
@title Stableswap
@author CurveFi
"""
from vyper.interfaces import ERC20

implements: ERC20


interface EIP1271:
    def isValidSignature(_digest: bytes32, _signature: Bytes[65]) -> bytes4: view


event Approval:
    owner: indexed(address)
    spender: indexed(address)
    value: uint256

event Transfer:
    sender: indexed(address)
    receiver: indexed(address)
    value: uint256


NAME: constant(String[32]) = ""
SYMBOL: constant(String[16]) = ""
VERSION: constant(String[8]) = ""

EIP712_TYPEHASH: constant(bytes32) = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)")
NAME_HASH: constant(bytes32) = keccak256(NAME)
VERSION_HASH: constant(bytes32) = keccak256(VERSION)

EIP2612_TYPEHASH: constant(bytes32) = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")

EIP1271_MAGIC: constant(bytes4) = 0x1626ba7e


CACHED_CHAIN_ID: immutable(uint256)
SALT: immutable(bytes32)
CACHED_DOMAIN_SEPARATOR: immutable(bytes32)


allowance: public(HashMap[address, HashMap[address, uint256]])
balanceOf: public(HashMap[address, uint256])
totalSupply: public(uint256)

nonces: public(HashMap[address, uint256])


@external
def __init__():
    CACHED_CHAIN_ID = chain.id
    SALT = convert(block.timestamp, bytes32)
    CACHED_DOMAIN_SEPARATOR = keccak256(
        _abi_encode(
            EIP712_TYPEHASH,
            NAME_HASH,
            VERSION_HASH,
            chain.id,
            self,
            block.timestamp,
        )
    )


@internal
def _approve(_owner: address, _spender: address, _value: uint256):
    self.allowance[_owner][_spender] = _value

    log Approval(_owner, _spender, _value)


@internal
def _burn(_sender: address, _value: uint256):
    self.balanceOf[_sender] -= _value

    log Transfer(_sender, ZERO_ADDRESS, _value)


@internal
def _mint(_receiver: address, _value: uint256):
    assert _receiver not in [self, ZERO_ADDRESS]

    self.balanceOf[_receiver] += _value
    log Transfer(ZERO_ADDRESS, _receiver, _value)


@internal
def _transfer(_sender: address, _receiver: address, _value: uint256):
    assert _receiver not in [self, ZERO_ADDRESS]

    self.balanceOf[_sender] -= _value
    self.balanceOf[_receiver] += _value

    log Transfer(_sender, _receiver, _value)


@view
@internal
def _domain_separator() -> bytes32:
    if chain.id != CACHED_CHAIN_ID:
        return keccak256(
            _abi_encode(
                EIP712_TYPEHASH,
                NAME_HASH,
                VERSION_HASH,
                chain.id,
                self,
                SALT,
            )
        )
    return CACHED_DOMAIN_SEPARATOR


@external
def transferFrom(_sender: address, _receiver: address, _value: uint256) -> bool:
    allowance: uint256 = self.allowance[_sender][msg.sender]
    if allowance != MAX_UINT256:
        self._approve(_sender, msg.sender, allowance - _value)

    self._transfer(_sender, _receiver, _value)
    return True


@external
def transfer(_receiver: address, _value: uint256) -> bool:
    self._transfer(msg.sender, _receiver, _value)
    return True


@external
def approve(_spender: address, _value: uint256) -> bool:
    self._approve(msg.sender, _spender, _value)
    return True


@external
def permit(_owner: address, _spender: address, _value: uint256, _deadline: uint256, _v: uint8, _r: bytes32, _s: bytes32) -> bool:
    assert _owner != ZERO_ADDRESS and block.timestamp <= _deadline

    nonce: uint256 = self.nonces[_owner]
    digest: bytes32 = keccak256(
        concat(
            b"\x19\x01",
            self._domain_separator(),
            keccak256(_abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline))
        )
    )

    if _owner.is_contract:
        signature: Bytes[65] = concat(_r, _s, slice(convert(_v, bytes32), 31, 1))
        assert EIP1271(_owner).isValidSignature(digest, signature) == EIP1271_MAGIC
    else:
        assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner

    self.nonces[_owner] = nonce + 1
    self._approve(_owner, _spender, _value)
    return True


@external
def increaseAllowance(_spender: address, _add_value: uint256) -> bool:
    cached_allowance: uint256 = self.allowance[msg.sender][_spender]
    allowance: uint256 = unsafe_add(cached_allowance, _add_value)

    if allowance < cached_allowance:
        # an overflow occurred
        allowance = MAX_UINT256

    if allowance != cached_allowance:
        self._approve(msg.sender, _spender, allowance)

    return True


@external
def decreaseAllowance(_spender: address, _sub_value: uint256) -> bool:
    cached_allowance: uint256 = self.allowance[msg.sender][_spender]
    allowance: uint256 = unsafe_sub(cached_allowance, _sub_value)

    if allowance > cached_allowance:
        # an underflow occurred
        allowance = 0

    if allowance != cached_allowance:
        self._approve(msg.sender, _spender, allowance)

    return True


@external
def burnFrom(_sender: address, _value: uint256) -> bool:
    allowance: uint256 = self.allowance[_sender][msg.sender]
    if allowance != MAX_UINT256:
        self._approve(_sender, msg.sender, allowance - _value)

    self._burn(_sender, _value)
    return True


@external
def burn(_value: uint256) -> bool:
    self._burn(msg.sender, _value)
    return True


@pure
@external
def name() -> String[32]:
    return NAME


@pure
@external
def symbol() -> String[16]:
    return SYMBOL


@pure
@external
def decimals() -> uint8:
    return 18


@pure
@external
def version() -> String[8]:
    return VERSION


@pure
@external
def salt() -> bytes32:
    return SALT


@view
@external
def DOMAIN_SEPARATOR() -> bytes32:
    return self._domain_separator()
