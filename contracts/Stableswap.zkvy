# @zk-version 1.2.0
"""
@title Stableswap
@author CurveFi
"""
from vyper.interfaces import ERC20

implements: ERC20


interface EIP20:
    def decimals() -> uint8: view

interface EIP1271:
    def isValidSignature(_digest: bytes32, _signature: Bytes[65]) -> bytes4: view


event Approval:
    owner: indexed(address)
    spender: indexed(address)
    value: uint256

event Transfer:
    sender: indexed(address)
    receiver: indexed(address)
    value: uint256

event CommitOwnership:
    future_owner: indexed(address)

event AcceptOwnership:
    previous_owner: indexed(address)
    new_owner: indexed(address)

event RampA:
    old_A: uint256
    new_A: uint256
    initial_time: uint256
    future_time: uint256

event StopRampA:
    A: uint256
    time: uint256

event CommitFee:
    deadline: uint256
    fee: uint256
    admin_fee: uint256

event ApplyFee:
    fee: uint256
    admin_fee: uint256

event RevertFee: pass


struct ParamA:
    future: uint256
    future_time: uint256
    initial: uint256
    initial_time: uint256

struct ParamFee:
    swap: uint256
    admin: uint256
    deadline: uint256
    future_swap: uint256
    future_admin: uint256


MASK_40: constant(uint256) = 2**40 - 1
MASK_64: constant(uint256) = 2**64 - 1

VERSION: constant(String[8]) = "1"

EIP712_TYPEHASH: constant(bytes32) = keccak256(
    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)"
)
VERSION_HASH: constant(bytes32) = keccak256(VERSION)

EIP2612_TYPEHASH: constant(bytes32) = keccak256(
    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
)
EIP1271_MAGIC: constant(bytes4) = 0x1626BA7E

N_COINS: constant(uint256) = 3
N_COINS_128: constant(int128) = 3
PRECISION: constant(uint256) = 10**18

A_PRECISION: constant(uint256) = 100
MAX_A: constant(uint256) = 1_000_000
MAX_A_CHANGE: constant(uint256) = 10
MIN_RAMP_TIME: constant(uint256) = 86400

MAX_FEE: constant(uint256) = 5 * 10**9  # 50%
MAX_ADMIN_FEE: constant(uint256) = 10**10  # 100%
FEE_DEADLINE_DELTA: constant(uint256) = 3 * 86400  # 3 days


NAME: immutable(String[32])
SYMBOL: immutable(String[16])

NAME_HASH: immutable(bytes32)
CACHED_CHAIN_ID: immutable(uint256)
SALT: immutable(bytes32)
CACHED_DOMAIN_SEPARATOR: immutable(bytes32)

COINS: immutable(address[N_COINS])
RATES: immutable(uint256[N_COINS])


allowance: public(HashMap[address, HashMap[address, uint256]])
balanceOf: public(HashMap[address, uint256])
totalSupply: public(uint256)

nonces: public(HashMap[address, uint256])

owner: public(address)
future_owner: public(address)

# [uint64 initial_A_time || uint64 initial_A || uint64 future_A_time || uint64 future_A]
packed_A: uint256
# [uint56 <empty> || uint40 future_admin_fee || uint40 future_fee || uint40 deadline || uint40 admin_fee || uint40 fee]
packed_fee: uint256


@external
def __init__(
    _name: String[32],
    _symbol: String[16],
    _coins: address[N_COINS],
    _A: uint256,
    _fee: uint256,
    _admin_fee: uint256
):
    assert _A <= MAX_A
    assert _fee <= MAX_FEE
    assert _admin_fee <= _admin_fee

    rates: uint256[N_COINS] = empty(uint256[N_COINS])
    for i in range(N_COINS):
        assert _coins[i] != ZERO_ADDRESS
        rates[i] = 10 ** (36 - convert(EIP20(_coins[i]).decimals(), uint256))

    NAME = _name
    SYMBOL = _symbol
    COINS = _coins
    RATES = rates

    NAME_HASH = keccak256(_name)
    CACHED_CHAIN_ID = chain.id
    SALT = convert(block.timestamp, bytes32)
    CACHED_DOMAIN_SEPARATOR = keccak256(
        _abi_encode(
            EIP712_TYPEHASH,
            NAME_HASH,
            VERSION_HASH,
            chain.id,
            self,
            block.timestamp,
        )
    )

    self.packed_A = _A * A_PRECISION
    self.packed_fee = shift(_admin_fee, 40) + _fee
    self.owner = msg.sender

    log AcceptOwnership(ZERO_ADDRESS, msg.sender)


@internal
def _approve(_owner: address, _spender: address, _value: uint256):
    self.allowance[_owner][_spender] = _value

    log Approval(_owner, _spender, _value)


@internal
def _burn(_sender: address, _value: uint256):
    self.balanceOf[_sender] -= _value

    log Transfer(_sender, ZERO_ADDRESS, _value)


@internal
def _mint(_receiver: address, _value: uint256):
    assert _receiver not in [self, ZERO_ADDRESS]

    self.balanceOf[_receiver] += _value
    log Transfer(ZERO_ADDRESS, _receiver, _value)


@internal
def _transfer(_sender: address, _receiver: address, _value: uint256):
    assert _receiver not in [self, ZERO_ADDRESS]

    self.balanceOf[_sender] -= _value
    self.balanceOf[_receiver] += _value

    log Transfer(_sender, _receiver, _value)


@view
@internal
def _domain_separator() -> bytes32:
    if chain.id != CACHED_CHAIN_ID:
        return keccak256(
            _abi_encode(
                EIP712_TYPEHASH,
                NAME_HASH,
                VERSION_HASH,
                chain.id,
                self,
                SALT,
            )
        )
    return CACHED_DOMAIN_SEPARATOR


@view
@internal
def _load_packed_fee() -> ParamFee:
    packed_fee: uint256 = self.packed_fee
    return ParamFee(
        {
            swap: bitwise_and(packed_fee, MASK_40),
            admin: bitwise_and(shift(packed_fee, -40), MASK_40),
            deadline: bitwise_and(shift(packed_fee, -80), MASK_40),
            future_swap: bitwise_and(shift(packed_fee, -120), MASK_40),
            future_admin: shift(packed_fee, -160)
        }
    )


@internal
def _store_packed_fee(_value: ParamFee):
    values: uint256[5] = [_value.swap, _value.admin, _value.deadline, _value.future_swap, _value.future_admin]

    packed_fee: uint256 = 0
    for i in range(5):
        assert values[i] < 2**40
        packed_fee += shift(values[i], i * 40)

    self.packed_fee = packed_fee


@view
@internal
def _load_packed_A() -> ParamA:
    packed_A: uint256 = self.packed_A
    return ParamA(
        {
            future: bitwise_and(packed_A, MASK_64),
            future_time: bitwise_and(shift(packed_A, -64), MASK_64),
            initial: bitwise_and(shift(packed_A, -128), MASK_64),
            initial_time: shift(packed_A, -196),
        }
    )


@internal
def _store_packed_A(_value: ParamA):
    values: uint256[4] = [_value.future, _value.future_time, _value.initial, _value.initial_time]

    packed_A: uint256 = 0
    for i in range(4):
        assert values[i] < 2**64
        packed_A += shift(values[i], i * 64)

    self.packed_A = packed_A


@view
@internal
def _A() -> uint256:
    param_A: ParamA = self._load_packed_A()
    if block.timestamp < param_A.future_time:
        # Expressions in uint256 cannot have negative numbers, thus "if"
        if param_A.future > param_A.initial:
            return param_A.initial + (param_A.future - param_A.initial) * (
                block.timestamp - param_A.initial_time
            ) / (param_A.future_time - param_A.initial_time)
        else:
            return param_A.initial - (param_A.initial - param_A.future) * (
                block.timestamp - param_A.initial_time
            ) / (param_A.future_time - param_A.initial_time)

    else:  # when param_A.future_time == 0 or block.timestamp >= param_A.future_time
        return param_A.future


@pure
@internal
def _calc_xp(_rates: uint256[N_COINS], _balances: uint256[N_COINS]) -> uint256[N_COINS]:
    result: uint256[N_COINS] = empty(uint256[N_COINS])
    for i in range(N_COINS):
        result[i] = _rates[i] * _balances[i] / PRECISION
    return result


@pure
@internal
def _calc_D(_xp: uint256[N_COINS], _amp: uint256) -> uint256:
    """
    D invariant calculation in non-overflowing integer operations
    iteratively

    A * sum(x_i) * n**n + D = A * D * n**n + D**(n+1) / (n**n * prod(x_i))

    Converging solution:
    D[j+1] = (A * n**n * sum(x_i) - D[j]**(n+1) / (n**n prod(x_i))) / (A * n**n - 1)
    """
    S: uint256 = 0
    for x in _xp:
        S += x
    if S == 0:
        return 0

    D: uint256 = S
    Ann: uint256 = _amp * N_COINS
    for i in range(255):
        D_P: uint256 = D * D / _xp[0] * D / _xp[1] / (N_COINS)**2
        Dprev: uint256 = D
        D = (Ann * S / A_PRECISION + D_P * N_COINS) * D / ((Ann - A_PRECISION) * D / A_PRECISION + (N_COINS + 1) * D_P)
        # Equality with the precision of 1
        if D > Dprev:
            if D - Dprev <= 1:
                return D
        else:
            if Dprev - D <= 1:
                return D
    # convergence typically occurs in 4 rounds or less, this should be unreachable!
    # if it does happen the pool is borked and LPs can withdraw via `remove_liquidity`
    raise


@pure
@internal
def _calc_y_D(A: uint256, i: int128, xp: uint256[N_COINS], D: uint256) -> uint256:
    """
    Calculate x[i] if one reduces D from being calculated for xp to D

    Done by solving quadratic equation iteratively.
    x_1**2 + x_1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)
    x_1**2 + b*x_1 = c

    x_1 = (x_1**2 + c) / (2*x_1 + b)
    """
    # x in the input is converted to the same price/precision

    assert i >= 0  # dev: i below zero
    assert i < N_COINS_128  # dev: i above N_COINS

    S_: uint256 = 0
    _x: uint256 = 0
    y_prev: uint256 = 0
    c: uint256 = D
    Ann: uint256 = A * N_COINS

    for _i in range(N_COINS_128):
        if _i != i:
            _x = xp[_i]
        else:
            continue
        S_ += _x
        c = c * D / (_x * N_COINS)

    c = c * D * A_PRECISION / (Ann * N_COINS)
    b: uint256 = S_ + D * A_PRECISION / Ann
    y: uint256 = D

    for _i in range(255):
        y_prev = y
        y = (y*y + c) / (2 * y + b - D)
        # Equality with the precision of 1
        if y > y_prev:
            if y - y_prev <= 1:
                return y
        else:
            if y_prev - y <= 1:
                return y
    raise


@view
@internal
def _get_D(_rates: uint256[N_COINS], _balances: uint256[N_COINS], _amp: uint256) -> uint256:
    xp: uint256[N_COINS] = self._calc_xp(_rates, _balances)
    return self._calc_D(xp, _amp)


@view
@internal
def _get_y(i: int128, j: int128, x: uint256, xp: uint256[N_COINS]) -> uint256:
    """
    Calculate x[j] if one makes x[i] = x

    Done by solving quadratic equation iteratively.
    x_1**2 + x_1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)
    x_1**2 + b*x_1 = c

    x_1 = (x_1**2 + c) / (2*x_1 + b)
    """
    # x in the input is converted to the same price/precision

    assert i != j       # dev: same coin
    assert j >= 0       # dev: j below zero
    assert j < N_COINS_128  # dev: j above N_COINS

    # should be unreachable, but good for safety
    assert i >= 0
    assert i < N_COINS_128

    amp: uint256 = self._A()
    D: uint256 = self._calc_D(xp, amp)
    S_: uint256 = 0
    _x: uint256 = 0
    y_prev: uint256 = 0
    c: uint256 = D
    Ann: uint256 = amp * N_COINS

    for _i in range(N_COINS_128):
        if _i == i:
            _x = x
        elif _i != j:
            _x = xp[_i]
        else:
            continue
        S_ += _x
        c = c * D / (_x * N_COINS)

    c = c * D * A_PRECISION / (Ann * N_COINS)
    b: uint256 = S_ + D * A_PRECISION / Ann  # - D
    y: uint256 = D

    for _i in range(255):
        y_prev = y
        y = (y*y + c) / (2 * y + b - D)
        # Equality with the precision of 1
        if y > y_prev:
            if y - y_prev <= 1:
                return y
        else:
            if y_prev - y <= 1:
                return y
    raise


@view
@internal
def _calc_withdraw_one_coin(_burn_amount: uint256, i: int128) -> uint256[2]:
    # First, need to calculate
    # * Get current D
    # * Solve Eqn against y_i for D - _token_amount
    amp: uint256 = self._A()
    rates: uint256[N_COINS] = RATES
    xp: uint256[N_COINS] = self._calc_xp(rates, self.balances)
    D0: uint256 = self._calc_D(xp, amp)

    total_supply: uint256 = self.totalSupply
    D1: uint256 = D0 - _burn_amount * D0 / total_supply
    new_y: uint256 = self.get_y_D(amp, i, xp, D1)

    base_fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))
    xp_reduced: uint256[N_COINS] = empty(uint256[N_COINS])

    for j in range(N_COINS):
        dx_expected: uint256 = 0
        xp_j: uint256 = xp[j]
        if j == i:
            dx_expected = xp_j * D1 / D0 - new_y
        else:
            dx_expected = xp_j - xp_j * D1 / D0
        xp_reduced[j] = xp_j - base_fee * dx_expected / FEE_DENOMINATOR

    dy: uint256 = xp_reduced[i] - self.get_y_D(amp, i, xp_reduced, D1)
    dy_0: uint256 = (xp[i] - new_y) * PRECISION / rates[i]  # w/o fees
    dy = (dy - 1) * PRECISION / rates[i]  # Withdraw less to account for rounding errors

    return [dy, dy_0 - dy]


@external
def transferFrom(_sender: address, _receiver: address, _value: uint256) -> bool:
    allowance: uint256 = self.allowance[_sender][msg.sender]
    if allowance != MAX_UINT256:
        self._approve(_sender, msg.sender, allowance - _value)

    self._transfer(_sender, _receiver, _value)
    return True


@external
def transfer(_receiver: address, _value: uint256) -> bool:
    self._transfer(msg.sender, _receiver, _value)
    return True


@external
def approve(_spender: address, _value: uint256) -> bool:
    self._approve(msg.sender, _spender, _value)
    return True


@external
def permit(
    _owner: address,
    _spender: address,
    _value: uint256,
    _deadline: uint256,
    _v: uint8,
    _r: bytes32,
    _s: bytes32,
) -> bool:
    assert _owner != ZERO_ADDRESS and block.timestamp <= _deadline

    nonce: uint256 = self.nonces[_owner]
    digest: bytes32 = keccak256(
        concat(
            b"\x19\x01",
            self._domain_separator(),
            keccak256(_abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline)),
        )
    )

    if _owner.is_contract:
        signature: Bytes[65] = concat(_r, _s, slice(convert(_v, bytes32), 31, 1))
        assert EIP1271(_owner).isValidSignature(digest, signature) == EIP1271_MAGIC
    else:
        assert (
            ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256))
            == _owner
        )

    self.nonces[_owner] = nonce + 1
    self._approve(_owner, _spender, _value)
    return True


@external
def increaseAllowance(_spender: address, _add_value: uint256) -> bool:
    cached_allowance: uint256 = self.allowance[msg.sender][_spender]
    allowance: uint256 = unsafe_add(cached_allowance, _add_value)

    if allowance < cached_allowance:
        # an overflow occurred
        allowance = MAX_UINT256

    if allowance != cached_allowance:
        self._approve(msg.sender, _spender, allowance)

    return True


@external
def decreaseAllowance(_spender: address, _sub_value: uint256) -> bool:
    cached_allowance: uint256 = self.allowance[msg.sender][_spender]
    allowance: uint256 = unsafe_sub(cached_allowance, _sub_value)

    if allowance > cached_allowance:
        # an underflow occurred
        allowance = 0

    if allowance != cached_allowance:
        self._approve(msg.sender, _spender, allowance)

    return True


@external
def burnFrom(_sender: address, _value: uint256) -> bool:
    allowance: uint256 = self.allowance[_sender][msg.sender]
    if allowance != MAX_UINT256:
        self._approve(_sender, msg.sender, allowance - _value)

    self._burn(_sender, _value)
    return True


@external
def burn(_value: uint256) -> bool:
    self._burn(msg.sender, _value)
    return True


@external
def ramp_A(_future_A: uint256, _future_time: uint256):
    assert msg.sender == self.owner
    assert _future_A != 0 and _future_A <= MAX_A
    assert _future_time >= block.timestamp + MIN_RAMP_TIME

    initial_A: uint256 = self._A()
    future_A: uint256 = _future_A * A_PRECISION

    if initial_A < future_A:
        # increasing
        assert future_A <= initial_A * MAX_A_CHANGE
    else:
        # decreasing
        assert future_A * MAX_A_CHANGE >= initial_A

    self._store_packed_A(
        ParamA(
            {
                future: future_A,
                future_time: _future_time,
                initial: initial_A,
                initial_time: block.timestamp,
            }
        )
    )
    log RampA(initial_A, future_A, block.timestamp, _future_time)


@external
def stop_ramp_A():
    assert msg.sender == self.owner

    current_A: uint256 = self._A()
    self._store_packed_A(
        ParamA(
            {
                future: current_A,
                future_time: block.timestamp,
                initial: current_A,
                initial_time: block.timestamp,
            }
        )
    )
    log StopRampA(current_A, block.timestamp)


@external
def commit_new_fee(_new_fee: uint256, _new_admin_fee: uint256):
    assert msg.sender == self.owner
    assert _new_fee <= MAX_FEE and _new_admin_fee <= MAX_ADMIN_FEE

    param_fee: ParamFee = self._load_packed_fee()
    assert param_fee.deadline == 0

    param_fee.deadline = block.timestamp + FEE_DEADLINE_DELTA
    param_fee.future_swap = _new_fee
    param_fee.future_admin = _new_admin_fee

    self._store_packed_fee(param_fee)
    log CommitFee(param_fee.deadline, _new_fee, _new_admin_fee)


@external
def apply_new_fee():
    assert msg.sender == self.owner

    param_fee: ParamFee = self._load_packed_fee()
    assert param_fee.deadline != 0 and param_fee.deadline <= block.timestamp

    param_fee.swap = param_fee.future_swap
    param_fee.admin = param_fee.future_admin
    param_fee.deadline = 0

    self._store_packed_fee(param_fee)
    log ApplyFee(param_fee.swap, param_fee.admin)


@external
def revert_new_fee():
    assert msg.sender == self.owner

    param_fee: ParamFee = self._load_packed_fee()
    assert param_fee.deadline != 0

    param_fee.deadline = 0

    self._store_packed_fee(param_fee)
    log RevertFee()


@external
def commit_transfer_ownership(_future_owner: address):
    assert msg.sender == self.owner

    self.future_owner = _future_owner
    log CommitOwnership(_future_owner)


@external
def accept_transfer_ownership():
    assert msg.sender == self.future_owner

    log AcceptOwnership(self.owner, msg.sender)
    self.owner = msg.sender


@pure
@external
def name() -> String[32]:
    return NAME


@pure
@external
def symbol() -> String[16]:
    return SYMBOL


@pure
@external
def decimals() -> uint8:
    return 18


@pure
@external
def version() -> String[8]:
    return VERSION


@pure
@external
def salt() -> bytes32:
    return SALT


@view
@external
def DOMAIN_SEPARATOR() -> bytes32:
    return self._domain_separator()


@view
@external
def A() -> uint256:
    return self._A() / A_PRECISION


@view
@external
def A_precise() -> uint256:
    return self._A()


@view
@external
def initial_A() -> uint256:
    return self._load_packed_A().initial


@view
@external
def initial_A_time() -> uint256:
    return self._load_packed_A().initial_time


@view
@external
def future_A() -> uint256:
    return self._load_packed_A().future


@view
@external
def future_A_time() -> uint256:
    return self._load_packed_A().future_time


@view
@external
def fee() -> uint256:
    return self._load_packed_fee().swap


@view
@external
def admin_fee() -> uint256:
    return self._load_packed_fee().admin


@view
@external
def fee_deadline() -> uint256:
    return self._load_packed_fee().deadline


@view
@external
def future_fee() -> uint256:
    return self._load_packed_fee().future_swap


@view
@external
def future_admin_fee() -> uint256:
    return self._load_packed_fee().future_admin


@view
@external
def coins(_idx: uint256) -> address:
    return COINS[_idx]


@view
@external
def rate_multipliers(_idx: uint256) -> uint256:
    return RATES[_idx]
